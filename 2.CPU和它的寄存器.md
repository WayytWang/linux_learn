---
typora-root-url: pic
---

# CPU和它的寄存器

- CPU(Central Processing Unit)。

## 计算机的工作模式

![](D:\note\note\wang\linux_learn\pic\计算机工作模式.png)
  - CPU是计算机最核心的硬件，它需要和其他硬件配合起来工作。
  - 图中能看到CPU与其他硬件是通过总线(Bus)连接起来的。它们之间的数据传递依靠的都是总线。
  - 其他硬件中最重要的就是内存(Memory)。内存是用来存储指令和指令操作的数据的。

      - 指令分为两部分：
          - 具体的操作，比如加法、减法等。
          - 需要参与操作的数据。

## CPU和内存是如何配合的

- 首先看CPU的组成，它分为三个部分：
  - 运算单元
    - 只管指令的运算部分，如加减法，位移等运算。但是它并不知道要运算哪些数据，也不知道计算的结果需要存在哪里。
  - 数据单元
    - 在描述内存的基本作用时，讲到数据存储在内存中，但是如果运算单元每次计算时都需要通过总线从内存中读取数据，那么CPU的处理速度就太慢。而对于一部分需要经常访问的数据，可以存储在数据单元，它虽然空间不大，但是速度飞快。数据单元包括CPU的缓存和寄存器组。
  - 控制单元
    - 控制单元是一个指挥中心，它可以不断获取下一条要执行的指令，然后执行。这条指令会指导运算单元从数据单元取出数据，计算结果，然后存到数据单元中。
- 而数据单元的存储空间非常有限，没办法保存太多的运算过程中产生的中间结果，内存来存储这些中间结果的。
  
- 配合图示：


![](D:\note\note\wang\linux_learn\pic\cpu与内存的合作.png)
     

- 编写的程序是放在硬盘上的，但程序执行时，躺着的代码就变成了活着的进程。在内存中就会有对应的空间。
- 图中有A，B两个进程。在内存中就有两个独立的内存空间，各自加载了自己的程序。进程的内存空间可以简单的理解成分为代码段和数据段两个部分。
- 每一个进程的内存空间是相互隔离的，但是并不一定是连续的，有点链表的意思。
- 控制单元听上去是最神奇的，它是如何知道当前需要执行哪一条指令的呢？
  - 它有一个**指令指针寄存器**，里面存放着下一条需要执行的指令的地址（在当前的进程的内存空间中）。
  - 控制单元会不断地从指令指针寄存器中拿到指令地址，并从内存中读到指令，然后写入它的指令寄存器。
  - 当指令寄存器中有指令时，控制单元就会把指令的计算部分交给运算单元，数据部分交给数据单元。
    - 数据单元会根据数据的地址，从内存空间中的数据段读数据保存在数据寄存器中。
    - 完成运算后的结果会先存在数据寄存器中。最终会有指令将这些数据又写回内存空间中。
  - 整个控制单元的工作流程，只要保证指令指针寄存器中会有值更新，那么进程就能一步步运行下去。指令指针寄存器的值是如何更新的，之后的文章会讨论到。
- 当一个CPU同一时间段要同时处理多个进程时，是如何切换进程的呢？
  - CPU有两个寄存器，一个存着当前处理进程的代码段起始位置，另一个存储当前处理进程的数据段起始位置。
  - 当从A进程切换到B进程的时候，就是替换这两个寄存器的值。
  - 当然进程切换还有会非常多的复杂操作，之后再详细分析。
- 图中内存部分和CPU部分之间的实线箭头就是总线。CPU和内存之间的数据传输就是靠的总线。
  - 传输数据的叫数据总线。
  - 传输地址的叫地址总线。
  - 总线的位数就决定了传输的能力。
    - 比如地址总线只有2位。那CPU就只能读到内存中的4个位置：00,01,10,11。
    - 比如数据总线只有2位，那一次传输就只能2位。如果需要传输一个8位的数，就需要4次。数据总线的位数决定了传输速度。






































































### CPU和内存是如何配合工作的？

#### 指令

- 首先简单的介绍下指令的意思。

- 写好的程序代码计算机并不能直接运行，它需要执行一系列的操作(汇编、编译)称为计算机认识的格式。
- 处理好的程序就是由一条条的指令组成的，指令会操作一些数据。
- 指令分成两部分：一部分是做什么操作，比如是加法还是位移；另一部分是操作那些数据。
- 第一部分由运算单元做，第二部分交给数据单元。

#### CPU是怎么获得指令，执行指令，产生结果并且写入内存的？

- 在控制单元中，有一个**指令指针寄存器**(Instruction Pointer Register)，它里面存放的是下一条指令在**内存**中的地址，控制单元会不停的根据地址将内存中代码段的指令拿进来，先放入**指令寄存器**。
- CPU就是通过控制单元的指令指针寄存器获得指令的。
- 拿到真正的指令之后就要开始执行，运算的部分就交给运算单元，而数据的获取就需要依靠数据单元。
- 数据单元通过数据的地址，从内存数据段中读到数据，存在数据寄存器中，就可以参与运算了。
- 运算单元计算完后，产生的结果会暂存在数据单元的数据寄存器中，会有指令将数据写回到内存中的数据段。

### 进程切换

- CPU中有两个寄存器，专门保存当前处理进程的代码段的起始地址和数据段的起始地址。当进程切换时会切换两个起始地址。

#### 总线

- CPU和内存之间来来回回传递数据，都是靠总线。总线的位置决定了一次能传输多少数据(地址也是数据)，总线根据传输数据的不同分为两类：
  - 地址总线
    - 传输地址数据，总线位数决定了能访问的地址范围有多广。
  - 数据总线
    - 传输真正的数据，总线的位数决定了能拿多大的数据。



## 8086

- 地址总线只有20位，数据总线16位

### 数据单元

- 8个16位的通用寄存器，其中还有的会被分为两个8位的寄存器
- AX,BX,CX,DX,SP,BP,SI,DI      AH,AL,BH,BL,CH,CL,DH,DL,SP,BP,SI,DI
- 这些寄存器主要用于在计算过程中暂存数据。

### 控制单元

- IP寄存器：指令指针寄存器，CPU不断的将指令从内存的代码段中，加载CPU的指令队列中，然后交给运算单元去执行。
- 切换进程相关：每个进程分为代码段和数据段，为了指向不同进程的地址空间，有四个16位的段寄存器：
  - CS Code Segment Register
  - DS Data Segment Register
  - SS Stack Register
  - ES

### 如何在内存中找指令和数据

- CS和DS存的是一个段的起始地址
- IP寄存器和通用寄存器中保存的是偏移量
- 真实地址 = 起始地址 + 偏移量

### 地址总线的位数是20

- 起始地址 * 16 + 偏移量
- 起始就是左移了四位
- 类比10进制。1左移4位 就是 10000 = 1 * 10^4,二进制就是 16 = 1 * 2^4
- 由于地址总线只有20位，所以最多只能访问到内存中 2^20 = 1M的空间
- 偏移量是保存在寄存器的 寄存器最多就16位 所以一个段的最大也就64K

### 32处理器

- 32位处理器，地址总线变成了32位 这会可以访问4G内存了
- 通用寄存器扩展了
- IP寄存器扩展了
- 段寄存器改动比较大
  - 换了一种方式
  - 段寄存器不在保存真正的起始地址，真正的起始地址保存在内存中的某个地方。这个地方是一个表格
    - 一项一项的内容：段描述符 Segment Descriptor 这里才保存真正的段起始地址
    - 段寄存器保存的是表格中的哪一项，称为选择子 Selector
- 为了效率 在CPU中会有描述符高速缓存器中。

### 实模式 保护模式

- 系统启动时 还是采用8086的老样子，只能访问1M的内存
- 切换到保护模式后，才能发挥更强大的能力

